#!/usr/bin/env python3
"""
Clean up multiple entity resolution databases.

This script identifies and cleans up duplicate/leftover entity resolution databases
that accumulate from test/demo runs without proper cleanup.
"""

import sys
import os
import json
from datetime import datetime
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from entity_resolution.utils.database import DatabaseManager
from entity_resolution.utils.config import Config

def analyze_databases(db_manager):
    """Analyze all entity resolution databases."""
    print("ğŸ” Analyzing entity resolution databases...")
    
    try:
        if not db_manager.test_connection():
            print("âŒ Could not connect to database")
            return None
        
        # Get system database connection
        sys_db = db_manager.get_database()
        client = db_manager.client
        
        # List all databases
        databases = sys_db.databases()
        print(f"ğŸ“Š Found {len(databases)} total databases")
        
        # Filter entity resolution databases
        entity_resolution_dbs = []
        for db_name in databases:
            if 'entity_resolution' in db_name and db_name != '_system':
                entity_resolution_dbs.append(db_name)
        
        print(f"ğŸ¯ Found {len(entity_resolution_dbs)} entity resolution databases:")
        
        db_analysis = {}
        for db_name in entity_resolution_dbs:
            try:
                db = client.db(db_name)
                collections = db.collections()
                
                # Separate custom vs system collections
                custom_collections = []
                system_collections = []
                
                for col in collections:
                    if col["name"].startswith('_'):
                        system_collections.append(col["name"])
                    else:
                        custom_collections.append(col["name"])
                
                db_analysis[db_name] = {
                    'total_collections': len(collections),
                    'custom_collections': custom_collections,
                    'system_collections': system_collections,
                    'has_data': len(custom_collections) > 0,
                    'custom_count': len(custom_collections)
                }
                
                print(f"  ğŸ“Š {db_name}:")
                print(f"    Total collections: {len(collections)}")
                print(f"    Custom collections: {len(custom_collections)}")
                if custom_collections:
                    print(f"    Custom data: {', '.join(custom_collections)}")
                else:
                    print(f"    Status: Empty (no custom data)")
                    
            except Exception as e:
                print(f"    âŒ Error analyzing {db_name}: {e}")
                db_analysis[db_name] = {'error': str(e)}
        
        return db_analysis
        
    except Exception as e:
        print(f"âŒ Error analyzing databases: {e}")
        return None

def recommend_cleanup(db_analysis):
    """Recommend which databases to clean up."""
    print("\nğŸ¯ Cleanup Recommendations:")
    
    empty_dbs = []
    test_dbs = []
    app_dbs = []
    other_dbs = []
    
    for db_name, analysis in db_analysis.items():
        if 'error' in analysis:
            continue
            
        if not analysis['has_data']:
            empty_dbs.append(db_name)
        elif 'test' in db_name:
            test_dbs.append(db_name)
        elif 'app' in db_name:
            app_dbs.append(db_name)
        else:
            other_dbs.append(db_name)
    
    print(f"ğŸ“‹ Empty databases (safe to delete): {len(empty_dbs)}")
    for db in empty_dbs:
        print(f"  - {db}")
    
    print(f"ğŸ“‹ Test databases (likely safe to delete): {len(test_dbs)}")
    for db in test_dbs:
        print(f"  - {db}")
    
    print(f"ğŸ“‹ App databases (check before deleting): {len(app_dbs)}")
    for db in app_dbs:
        print(f"  - {db}")
    
    print(f"ğŸ“‹ Other databases (review carefully): {len(other_dbs)}")
    for db in other_dbs:
        print(f"  - {db}")
    
    return {
        'empty': empty_dbs,
        'test': test_dbs,
        'app': app_dbs,
        'other': other_dbs
    }

def backup_database_data(db_manager, db_name, backup_dir="backups"):
    """Backup data from a database before deletion."""
    try:
        if not os.path.exists(backup_dir):
            os.makedirs(backup_dir)
        
        client = db_manager.client
        db = client.db(db_name)
        collections = db.collections()
        
        custom_collections = [col for col in collections if not col["name"].startswith('_')]
        
        if not custom_collections:
            print(f"  â„¹ï¸  {db_name}: no custom data to backup")
            return True
        
        print(f"  ğŸ“‹ {db_name}: backing up {len(custom_collections)} collections...")
        
        backup_data = {}
        for col_name in custom_collections:
            try:
                col = db.collection(col_name)
                cursor = col.all()
                documents = list(cursor)
                backup_data[col_name] = documents
                print(f"    - {col_name}: {len(documents)} documents")
            except Exception as e:
                print(f"    âŒ Error backing up {col_name}: {e}")
                return False
        
        # Save backup
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = os.path.join(backup_dir, f"database_{db_name}_backup_{timestamp}.json")
        
        with open(backup_file, 'w') as f:
            json.dump(backup_data, f, indent=2, default=str)
        
        print(f"  âœ… Backup saved: {backup_file}")
        return True
        
    except Exception as e:
        print(f"  âŒ Error backing up {db_name}: {e}")
        return False

def delete_database(db_manager, db_name):
    """Delete a database."""
    try:
        sys_db = db_manager.get_database()
        
        if not sys_db.has_database(db_name):
            print(f"  â„¹ï¸  {db_name}: database doesn't exist")
            return True
        
        print(f"  ğŸ—‘ï¸  Deleting database: {db_name}")
        sys_db.delete_database(db_name)
        print(f"  âœ… Deleted: {db_name}")
        return True
        
    except Exception as e:
        print(f"  âŒ Error deleting {db_name}: {e}")
        return False

def main():
    print("ğŸ§¹ Entity Resolution Database Cleanup")
    print("=" * 50)
    
    config = Config.from_env()
    db_manager = DatabaseManager()
    
    # Analyze current databases
    db_analysis = analyze_databases(db_manager)
    if not db_analysis:
        print("âŒ Could not analyze databases")
        return False
    
    # Get recommendations
    recommendations = recommend_cleanup(db_analysis)
    
    # Ask user what to do
    print(f"\nğŸ¤” What would you like to do?")
    print(f"1. Delete empty databases only (safest)")
    print(f"2. Delete empty + test databases")
    print(f"3. Delete all except one app database")
    print(f"4. Just show analysis (no changes)")
    
    try:
        choice = input("\nEnter your choice (1-4): ").strip()
    except KeyboardInterrupt:
        print("\nâŒ Operation cancelled by user")
        return False
    
    if choice == "4":
        print("âœ… Analysis complete. No changes made.")
        return True
    
    # Determine databases to delete
    databases_to_delete = []
    
    if choice == "1":
        databases_to_delete = recommendations['empty']
    elif choice == "2":
        databases_to_delete = recommendations['empty'] + recommendations['test']
    elif choice == "3":
        # Keep one app database, delete the rest
        all_dbs = list(db_analysis.keys())
        if recommendations['app']:
            # Keep the first app database
            keep_db = recommendations['app'][0]
            databases_to_delete = [db for db in all_dbs if db != keep_db]
            print(f"ğŸ“‹ Keeping app database: {keep_db}")
        else:
            databases_to_delete = all_dbs
    else:
        print("âŒ Invalid choice")
        return False
    
    if not databases_to_delete:
        print("âœ… No databases to delete")
        return True
    
    print(f"\nğŸ—‘ï¸  Databases to delete: {len(databases_to_delete)}")
    for db in databases_to_delete:
        print(f"  - {db}")
    
    # Confirm deletion
    try:
        confirm = input(f"\nâš ï¸  Are you sure you want to delete these databases? (yes/no): ").lower().strip()
        if confirm not in ['yes', 'y']:
            print("âŒ Operation cancelled by user")
            return False
    except KeyboardInterrupt:
        print("\nâŒ Operation cancelled by user")
        return False
    
    # Backup and delete databases
    print(f"\nğŸ’¾ Backing up databases with data...")
    backup_success = True
    for db_name in databases_to_delete:
        if db_analysis.get(db_name, {}).get('has_data', False):
            if not backup_database_data(db_manager, db_name):
                backup_success = False
    
    if not backup_success:
        print("âŒ Some backups failed. Aborting for safety.")
        return False
    
    print(f"\nğŸ—‘ï¸  Deleting databases...")
    deleted_count = 0
    for db_name in databases_to_delete:
        if delete_database(db_manager, db_name):
            deleted_count += 1
    
    print(f"\nğŸ‰ Successfully deleted {deleted_count} databases")
    print(f"ğŸ“ Data backups saved in 'backups/' directory")
    
    return True

if __name__ == "__main__":
    try:
        success = main()
        if success:
            print("\nğŸ‰ Database cleanup completed successfully!")
        else:
            print("\nâŒ Database cleanup failed!")
            sys.exit(1)
    except KeyboardInterrupt:
        print("\nâŒ Operation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\nâŒ Unexpected error: {e}")
        sys.exit(1)
